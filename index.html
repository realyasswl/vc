<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="static/style.css">
    <style>
        .photo {
            border: solid;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #557799;
            shape-rendering: crispEdges;
        }
    </style>
    <script src="static/d3.js" charset="utf-8"></script>
    <script src="static/li.js" charset="utf-8"></script>
    <script src="static/jquery-2.2.0.js" charset="utf-8"></script>
    <script>
        var margin_length = 40;
        var margin = {
            top: margin_length, right: margin_length,
            bottom: margin_length, left: margin_length
        };
        //        var v = {height: 920, width: 1900};
        var v = {height: 800, width: 1700};
        var o = {x: 0, y: 0, h: v.height, w: v.width};
        var base_dir = "photodir/";
        var info_file = "info.csv";
        var dataset;
        var rate = {max: 1, min: .1, default: .3, step: .01};
        var interval = 500;
        //        canvas
        var svga;
        var x = d3.scale.linear().range([0, v.width]).domain([0, v.width]);
        var y = d3.scale.linear().range([0, v.height]).domain([0, v.height]);
        var modi = d3.scale.linear().range([0, 3]).domain([3, 0]);
        d3.csv(base_dir + info_file, function (error, data) {
            if (error) throw error;
            dataset = data.slice();
            base();
            draw_gallery();

            /**test area*
             svga.append("image")
             .attr("class", "test1")
             .attr("transform", "translate(100,100),rotate(0,204,153),scale("+rate.default+")")
             //             .attr("width", 408)
             //             .attr("height", 306)
             .attr("width", 3264)
             .attr("height", 2448)
             .attr("xlink:href", "photodir/2015-02-18 124445.jpg");
             svga.append("line")
             .attr("class", "test2")
             .attr("x1", 0)
             .attr("y1", 0)
             .attr("x2", 408)
             .attr("y2", 306)
             .attr("transform", "translate(100,100),rotate(90,204,153)")
             .attr("stroke", "black")
             .attr("stroke-width", 1);
             cycle();
             function cycle() {
                svga.select(".test1").transition().duration(interval)
                        .attrTween("transform", function () {
                                    return d3.interpolateString(d3.select(this).attr("transform"), "translate(100,100),rotate(180,204,153),scale("+rate.default+")");
                                }
                        ).each("end", cycle1);
            }

             function cycle1() {
                svga.select(".test1").transition().duration(interval)
                        .attrTween("transform", function () {
                                    return d3.interpolateString(d3.select(this).attr("transform"), "translate(200,200),rotate(180,204,153),scale("+rate.default+")");
                                }
                        ).each("end", cycle2);
            }

             function cycle2() {
                svga.select(".test1").transition().duration(interval)
                        .attrTween("transform", function () {
                                    return d3.interpolateString(d3.select(this).attr("transform"), "translate(200,200),rotate(360,204,153),scale("+rate.default+")");
                                }
                        ).each("end", cycle3);
            }
             function cycle3() {
                svga.select(".test1").transition().duration(interval)
                        .attrTween("transform", function () {
                                    return d3.interpolateString(d3.select(this).attr("transform"), "translate(100,100),rotate(0,204,153),scale("+rate.default+")");
                                }
                        ).each("end", cycle);
            }

             /**test area*/
        })
        function exceeds(d, o) {
            return d.i.top().y < o.y || d.i.right().x > o.x + o.w || d.i.bottom().y > o.y + o.h || d.i.left().x < o.x;
        }
        function draw_gallery() {
            init();
            console.dir(dataset);
            judge();

            function judge() {
                if (dataset.some(function (d0) {
                            return exceeds(d0, o)
                                    || (dataset.some(function (d1) {
                                                return overlap(d0, d1);
                                            })
//                                    && d0.i.rate < rate.max-rate.step
                                    );
                        })) {
                    cycle();
                }
            }

            function cycle() {
                dataset.sort(function (a, b) {
                    var ea = exceeds(a, o), eb = exceeds(b, o);
                    if (ea && !eb) {
                        return 1;
                    }
                    if (eb && !ea) {
                        return -1;
                    }
                    return 0;
                }).forEach(function (d) {
                            var x = d.i.x(), y = d.i.y();
                            var t, r, b, l = false;
                            /*solve exceeds*/

                            if (0 < 0 - d.i.top().y) {
                                t = true;
                                y += 0 - d.i.top().y;
                            }
                            if (0 > v.width - d.i.right().x) {
                                r = true;
                                x += v.width - d.i.right().x;
                            }
                            if (0 > v.height - d.i.bottom().y) {
                                b = true;
                                y += v.height - d.i.bottom().y;
                            }
                            if (0 < 0 - d.i.left().x) {
                                l = true;
                                x += 0 - d.i.left().x;
                            }

                            var adjacent = dataset.filter(function (d1) {
                                return overlap(d, d1);
                            }).slice();
//                            console.log(adjacent.length);
                            if (adjacent.length == 0) {
                                if (d.i.rate < rate.max) {
                                    d.i.update_rate(d.i.rate + rate.step);
                                }
                            } else {
                                if (d.i.rate > rate.min) {
                                    d.i.update_rate(d.i.rate - rate.step);
                                }
                                /* solve overlap*/
                                dataset.forEach(function (d1) {
                                    if (overlap(d, d1)) {
                                        x += (d.i.x() - d1.i.x()) / ( dataset.length);
                                        y += (d.i.y() - d1.i.y()) / ( dataset.length);
                                    }
                                });
                            }
                            x = d.i.x() + (x - d.i.x());
                            y = d.i.y() + (y - d.i.y());

                            d.i.locate(x, y);
                        }
                );

                svga.selectAll(".photo").data(dataset, function (p) {
                            return p.FileName;
                        })
                        .transition()
                        .duration(interval).ease("linear")
                        .attrTween("transform", function (p, index) {
                            var current = d3.select(this).attr("transform");
                            var to = "translate("
                                    + p.i.translate_x + ","
                                    + p.i.translate_y + "),rotate("
                                    + p.i.rotate
                                    + "," + p.i.w() / 2 + "," + p.i.h() / 2
                                    + "),scale(" + p.i.rate + ")";
                            return d3.interpolateString(current, to);
                        }).each("end", judge);
            }


            //                    .tween("width", photoTween);
            //            function photoTween(d, i, a) {
            //                return function (t) {
            //                    this.width = 1234;
            //                }
            //            }


            //                    .attr("transform", function (p, i) {
            //                                return "translate(" + p.i.translate_x + ","
            //                                        + p.i.translate_y + "),rotate("
            //                                        + p.i.rotate
            //                                        + "," + p.i.w() / 2 + "," + p.i.h() / 2
            //                                        + ")";
            //                            }
            //                    );
        }
        function overlap(d0, d1) {
            return doPolygonsIntersect(d0.i.vertexes(), d1.i.vertexes())
                    && (d0.FileName != d1.FileName);
        }
        function base() {
            svga = d3.select(".wrapper").append("svg")
                    .attr("width", v.width + margin.left + margin.right)
                    .attr("height", v.height + margin.top + margin.bottom)
                    .append("g").attr("class", "g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            var xAxis = d3.svg.axis().scale(x)
                    .orient("top");

            var yAxis = d3.svg.axis().scale(y)
                    .orient("left");
            svga.append("g")
                    .attr("class", "x axis")
                    //                    .attr("transform", "translate(0," + 2 * radius + ")")
                    .call(xAxis)
                    .append("text")
                    .attr("class", "label")
                    .attr("x", v.width)
                    .attr("y", -6)
                    .style("text-anchor", "end")
                    .text("x axis");

            svga.append("g")
                    .attr("class", "y axis")
                    .call(yAxis)
                    .append("text")
                    .attr("class", "label")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -12)
                    .attr("x", 12 - v.height)
                    .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .text("y axis")
        }
        function init() {
            dataset.forEach(function (d) {
                d.i = {
                    translate_x: 0,
                    translate_y: 0,
                    rate: rate.default,
                    rotate: 0
                };

                d.i.locate = function (x, y, a) {
                    d.i.translate_x = x - d.i.w() / 2;
                    d.i.translate_y = y - d.i.h() / 2;
                }
                d.i.update_rate = function (r, a) {
                    d.i.rate = r;
                }
                d.i.update_rotate = function (r, a) {
                    d.i.rotate = r;
                }
                d.i.w = function () {
                    return d.ExifImageWidth * d.i.rate;
//                    return d.ExifImageWidth;
                }
                d.i.h = function () {
                    return d.ExifImageHeight * d.i.rate;
//                    return d.ExifImageHeight;
                }

                /**Orientation indication
                 1        2       3      4         5            6           7          8

                 888888  888888      88  88      8888888888  88                  88  8888888888
                 88          88      88  88      88  88      88  88          88  88      88  88
                 8888      8888    8888  8888    88          8888888888  8888888888          88
                 88          88      88  88
                 88          88  888888  888888
                 */
                switch (d.Orientation) {
                    case "1":
                        d.i.rotate = 0;
                        break;
                    case "3":
                        d.i.rotate = 180;
                        break;
                    case "6":
                        d.i.rotate = 90;
                        break;
                    case "8":
                        d.i.rotate = -90;
                        break;
                    default:
                        d.i.rotate = 0;
                }
                d.i.x = function () {
                    return d.i.center().x;
                }
                d.i.y = function () {
                    return d.i.center().y;
                }
                // distance from one vertex to center of the rectangle
                d.i.radius = function () {
                    return Math.sqrt(Math.pow(d.i.w() / 2, 2) + Math.pow(d.i.h() / 2, 2));
                };
//                the angle between (center.x-x0,center.y-y0) and (x,0)
                d.i.base_angle = function () {
                    return rad2deg(Math.atan(d.ExifImageHeight / d.ExifImageWidth));
                };
                d.i.center = function () {
//                    center is always this value
//                    translate_x and translate_y is always this value, no matter rotate or not
                    return {
                        x: d.i.translate_x + d.i.w() / 2,
                        y: d.i.translate_y + d.i.h() / 2
                    };
                };
//                  return the four vertexes, in original clockwise order
//                  (0:top-left, 1:top-right,2:bottom-right,3"bottom-left)
                d.i.vertexes = function () {
                    var vertexes = [];
                    var cent = d.i.center();
                    vertexes.push({
                        x: cent.x - d.i.radius() * Math.cos(deg2rad(d.i.rotate + d.i.base_angle())),
                        y: cent.y - d.i.radius() * Math.sin(deg2rad(d.i.rotate + d.i.base_angle()))
                    });
                    vertexes.push({
                        x: vertexes[0].x + d.i.w() * Math.cos(deg2rad(d.i.rotate)),
                        y: vertexes[0].y + d.i.w() * Math.sin(deg2rad(d.i.rotate))
                    });
                    vertexes.push({
                        x: vertexes[1].x - d.i.h() * Math.sin(deg2rad(d.i.rotate)),
                        y: vertexes[1].y + d.i.h() * Math.cos(deg2rad(d.i.rotate))
                    });
                    vertexes.push({
                        x: vertexes[0].x - d.i.h() * Math.sin(deg2rad(d.i.rotate)),
                        y: vertexes[0].y + d.i.h() * Math.cos(deg2rad(d.i.rotate))
                    });
                    return vertexes;
                }
                d.i.top = function () {
                    var k = (4 - Math.floor(d.i.rotate / 90) % 4) % 4;
                    return d.i.vertexes()[k];
                }
                d.i.right = function () {
                    var k = (5 - Math.floor(d.i.rotate / 90) % 4) % 4;
                    return d.i.vertexes()[k];
                }
                d.i.bottom = function () {
                    var k = (6 - Math.floor(d.i.rotate / 90) % 4) % 4;
                    return d.i.vertexes()[k];
                }
                d.i.left = function () {
                    var k = (7 - Math.floor(d.i.rotate / 90) % 4) % 4;
                    return d.i.vertexes()[k];
                }
            });
            dataset.forEach(function (d, i) {
                var x = Math.random() * v.width;
                var y = Math.random() * v.height;
                d.i.locate(x, y);
//                i == 0 ? d.i.locate(20, 500) : d.i.locate(40, 540);
//                d.i.update_rotate(Math.random() * 360 - 180);
            });

            svga.selectAll(".photo").data(dataset, function (p) {
                return p.FileName;
            }).enter().append("image")
                    .attr("class", "photo")
                    .attr("transform", function (p, i) {
//                                console.log(p.i.center());
//                                console.log(p.i.translate_x, p.i.translate_y);
//                                console.log(p.i.top());
//                                console.log(p.i.right());
//                                console.log(p.i.bottom());
//                                console.log(p.i.left());

                                return "translate(" + p.i.translate_x + ","
                                        + p.i.translate_y + ")"
                                        + ",rotate("
                                        + p.i.rotate
                                        + "," + p.i.w() / 2 + "," + p.i.h() / 2
                                        + "),scale(" + p.i.rate + ")"
                                        ;
                            }
                    )
                    .attr("width", function (d) {
                        return d.ExifImageWidth;
                    })
                    .attr("height", function (d) {
                        return d.ExifImageHeight;
                    })
                    .attr("xlink:href", function (p) {
                        return base_dir + p.FileName;
                    });

            //            svga.selectAll(".test2").data(dataset, function (p) {
            //                return p.FileName;
            //            }).enter().append("line")
            //                    .attr("class", "test2")
            //                    .attr("x1", 0)
            //                    .attr("y1", 0)
            //                    .attr("x2", function(d){return  d.i.w();})
            //                    .attr("y2", function(d){return  d.i.h();})
            //                    .attr("transform", function(d){
            //                        return "translate("+d.i.translate_x+","+d.i.translate_y+"),rotate(0,"+d.i.w()/2+","+d.i.h()/2+")";
            //                    })
            //                    .attr("stroke", "black")
            //                    .attr("stroke-width", 1);
        }
        /**
         * Helper function to determine whether there is an intersection between the two polygons described
         * by the lists of vertices. Uses the Separating Axis Theorem
         *
         * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
         * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
         * @return true if there is any intersection between the 2 polygons, false otherwise
         */
        function doPolygonsIntersect(a, b) {
            var polygons = [a, b];
            var minA, maxA, projected, i, i1, j, minB, maxB;

            for (i = 0; i < polygons.length; i++) {

                // for each polygon, look at each edge of the polygon, and determine if it separates
                // the two shapes
                var polygon = polygons[i];
                for (i1 = 0; i1 < polygon.length; i1++) {

                    // grab 2 vertices to create an edge
                    var i2 = (i1 + 1) % polygon.length;
                    var p1 = polygon[i1];
                    var p2 = polygon[i2];

                    // find the line perpendicular to this edge
                    var normal = {x: p2.y - p1.y, y: p1.x - p2.x};

                    minA = maxA = undefined;
                    // for each vertex in the first shape, project it onto the line perpendicular to the edge
                    // and keep track of the min and max of these values
                    for (j = 0; j < a.length; j++) {
                        projected = normal.x * a[j].x + normal.y * a[j].y;
                        if (isUndefined(minA) || projected < minA) {
                            minA = projected;
                        }
                        if (isUndefined(maxA) || projected > maxA) {
                            maxA = projected;
                        }
                    }

                    // for each vertex in the second shape, project it onto the line perpendicular to the edge
                    // and keep track of the min and max of these values
                    minB = maxB = undefined;
                    for (j = 0; j < b.length; j++) {
                        projected = normal.x * b[j].x + normal.y * b[j].y;
                        if (isUndefined(minB) || projected < minB) {
                            minB = projected;
                        }
                        if (isUndefined(maxB) || projected > maxB) {
                            maxB = projected;
                        }
                    }

                    // if there is no overlap between the projects, the edge we are looking at separates the two
                    // polygons, and we know there is no overlap
                    if (maxA < minB || maxB < minA) {
//                        console.log("polygons don't intersect!");
                        return false;
                    }
                }
            }
            return true;
        }
        function isUndefined(a) {
            return a == undefined;
        }
        function rad2deg(r) {
            return r * 180 / Math.PI
        }
        function deg2rad(d) {
            return d * Math.PI / 180;
        }
    </script>
</head>
<body>
<div class="wrapper"></div>
</body>
</html>